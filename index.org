#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t reveal_title_slide:nil
#+REVEAL_HIGHLIGHT_CSS: solarized
#+REVEAL_THEME: solarized
#+REVEAL_ROOT: ./reveal.js-3.8.0

* Dwarlixir
A story of mistakes
Dwarf Fortress + Elixir + MUD, oh my
** Who you're listening to
Aldric "Trevoke" Giacomoni

#+begin_notes
<3 Ruby, Smalltalk，Lisp, Elixir
#+end_notes
** Why this talk? 1/2
#+begin_quote
I know it's everybody's sin

You got to lose to know

How to win

― Dream On, Aerosmith
#+end_quote
** Why this talk? 2/2
#+begin_quote
I look at the world and I notice it's turning

While my guitar gently weeps

With every mistake we must surely be learning

Still my guitar gently weeps

― The Beatles, While My Guitar Gently Weeps
#+end_quote
* Establishing context
** What's a MUD?
Multi-User Dungeon
Text-based multiplayer game
Read description
Write commands
Yes, text-based combat
** What's Dwarf Fortress?
Dwarf Fortress!
world simulation
What could possibly go wrong?
...
Let's find out!
* So what we're gonna aim for is…
A world map, with time passing, creatures that can move, die, and reproduce.

And a telnet connection for people

And then I balance out the ecosystem

I'm sure that'll be easy

** Roadmap
- [0/6]
  - [ ] algorithm improvement
  - [ ] extreme local state
  - [ ] distributed state
  - [ ] schedulers and the "tick"
  - [ ] flooding processes
  - [ ] linux oom killer
* Algorithm improvement
** Misconception
A list is like an array
** Story
#+REVEAL_HTML: <img class="stretch" src="landoflisp.png">
#+begin_notes
Land of Lisp

Grand Theft Wumpus
#+end_notes
** Graph
#+REVEAL_HTML: <img class="stretch" src="wumpus-map.png">

#+begin_notes
World: Graph

Edges and nodes

First, generate edges between pairs of nodes

Then traverse and, if you find any islands, connect them.

#+end_notes
** Impact
Lots of data structures initialized

Lots of data being copied

VERY SLOW
** Fix
#+REVEAL_HTML: <img class="stretch" src="algorithm-diff.png">
#+begin_notes
This is inside traverse/3 - a recursive call.
traverse/3 returns a list of visited nodes

Don't name your variables x and y unless they're cartesian coordinates

x is a list of visited nodes
y is a list of edges from this node
#+end_notes
** Roadmap
- [1/6]
  - [X] algorithm improvement
  - [ ] extreme local state
  - [ ] distributed state
  - [ ] schedulers and the "tick"
  - [ ] flooding processes
  - [ ] linux oom killer
* Extreme local state
** Misconception
extreme local state has got to be better than global state
** Story
"Actor model?" Moar like extreme object-oriented, amirite?

#+begin_notes
- Creatures
- GenServers
- Local state: can have hat or sunglasses
- "random action"
- Imagine the person can say "Nice hat" or "Nice Sunglasses"
- But they have to /check/ first of course.
- So they send a synchronous message to other processes to check what the state is
- But.. Other processes are all doing the same thing
#+end_notes
** Impact
A → B
B → C
C → A

Deadlocks
#+begin_notes
Think "Dining Philosophers" problem.
#+end_notes
** Fix 1
Some state is global.

I know it's a boring answer.
** Fix 2
Create
** Roadmap
- [2/6]
  - [X] algorithm improvement
  - [X] extreme local state
  - [ ] distributed state
  - [ ] schedulers and the "tick"
  - [ ] flooding processes
  - [ ] linux oom killer
* Distributed state
** Misconception
Fewer synchronous calls will reduce the opportunity of deadlocks
** Story
Moar local state in moar local places
#+begin_notes
I'd love to say that I figured out "some state is global" when I ran into the deadlocks

But that's just not true. Ι really wanted to not do databases.

So I started to copy some data into each process, because that allowed me to do fewer synchronous calls.

Surely that was going to work, right?
#+end_notes
** Impact
Accidentally multiple sources of truths
#+begin_notes
Because of super local
#+end_notes
** Roadmap
- [3/6]
  - [X] algorithm improvement
  - [X] extreme local state
  - [X] distributed state
  - [ ] schedulers and the "tick"
  - [ ] flooding processes
  - [ ] linux oom killer
* Schedulers and the "tick"
** Misconception
There won't be a sizable impact to sending lots of processes a message at the same time
** Story
The tick (not the blue one)

#+begin_notes
Registry, Petimer, self-ticks
#+end_notes
** Impact
All schedulers triggered at same time - literally a heartbeat of intense CPU usage on the box
** Fix
More or less "any other way"

I opted for "all manage their own ticks"

Never mind how untestable that makes the system
** Roadmap
- [4/6]
  - [X] algorithm improvement
  - [X] extreme local state
  - [X] distributed state
  - [X] schedulers and the "tick"
  - [ ] flooding processes
  - [ ] linux oom killer
* flooding processes
** Misconception
It's hard to send a process too many messages
** Impact

** Roadmap
- [5/6]
  - [X] algorithm improvement
  - [X] extreme local state
  - [X] distributed state
  - [X] schedulers and the "tick"
  - [X] flooding processes
  - [ ] linux oom killer
* linux OOM killer
** Misconception
My world simulation won't grow unboundedly in RAM usage
** Story
"Emergent Design"
#+begin_notes
world simulation: reproduction and death

balancing lifespan with likelihood of becoming pregnant and length of pregnancy is hard
#+end_notes
** Impact
The operating system does what it needs to do to stay up
#+begin_notes
I'd launch the game, and after an hour and a half someone would say "Hey, your game is down"
#+end_notes
** Roadmap
- [6/6]
  - [X] algorithm improvement
  - [X] extreme local state
  - [X] distributed state
  - [X] schedulers and the "tick"
  - [X] flooding processes
  - [X] linux oom killer
* Q&A
